#lang scribble/manual

@(require (for-label racket)
racket/match
racket/sandbox
scribble/example)

@title{handy/list-utils}
@author{David K. Storrs}

@defmodule[handy/list-utils]

@section{Introduction}

@racketmodname[handy] is a collection of utility libraries aimed at different purposes.  @racketmodname[handy/list-utils] contains (unsurprisingly) list-related utilities.

@(define eval
(call-with-trusted-sandbox-configuration
(lambda ()
(parameterize ([sandbox-output 'string]
[sandbox-error-output 'string]
[sandbox-memory-limit 50])
(make-evaluator 'racket)))))


@(define-syntax-rule (hlu-eval label body ...)
(examples #:label label #:eval ((make-eval-factory '("../list-utils.rkt" racket)))
body ...))

@subsection{Parameters}

The following parameters modify how @racket[vector->dict] and @racket[list->dict] work. Those two functions take a list of keys and a (list/vector) of values and turn them into a @racket[dict?], possibly doing various transformations along the way.

@defparam[current-transform-data-function func (-> any/c any/c pair?)]{This function will be mapped across the keys- and values lists in order to generate the list of pairs that will be passed to the @tech{dict-maker} function stored in the @racket[current-dict-maker-function] parameter. (see below)

Default: @racket[cons]}




@defparam[current-dict-maker-function func (-> (listof pair?) dict?)]{Controls how dicts are created.

Default: @racket[make-hash]}

@defparam[current-transform-dict-function func (-> dict? dict?)]{Takes the dict generated by the @racket[dict-maker] function and returns a (perhaps modified) version.

Default: @racket[identity]}


@subsection{Functions}

@defproc[(atom? [v any/c]) boolean?]{
Returns @racket[#f] if v is a pair, @racket[#f] otherwise.}

@defproc[(autobox [v any/c]) list?]{
If v is a list, returns v.  Otherwise, returns (list v)}

@defproc[(compose-fifo [v any/c] ...) procedure?]{
Like @racket[compose] but composes from left to right instead of right to left, so the first listed function is the first to receive the argument(s).}

@defproc[(disjunction [x hash?] [y hash?]) dict-disjunction?]{Takes a pair of hashes and returns a @racket[dict-disjunction] struct that contains a breakdown of the elements; see example below for what the struct looks like.  (NB:  I should either have named the struct @racket[hash-disjunction] or the contract should have been for @racket[dict?]@racketidfont{s} instead of @racket[hash?]@racketidfont{s}.)
@(hlu-eval
#f
(struct dict-disjunction (different only-in-first only-in-second dict-first dict-second) #:transparent)
(pretty-print	(disjunction (hash 'a 1 'b 2 'c 3) (hash 'a 2 'd 4))))}

@defproc[(first* [l list?]) (not/c pair?)]{Returns the first atom in a (possibly nested) list.
@(hlu-eval #f
(first* '(a b c))
(first* '(((a b)))))}

@defproc*[([(in-range-inc [end real?]) stream?]
[(in-range-inc [start real?] [end real?] [step real? 1]) stream?])]{Like @racket[in-range] but includes the endpoint.
@(hlu-eval #f
(for/list ([i (in-range 0 3)])  i)
(for/list ([i (in-range-inc 0 3)])  i)
(for/list ([i (in-range-inc 3)])  i)
(for/list ([i (in-range-inc 0 3 0.5)]) i))}

@defproc[(insert-at [orig list?] [new list?] [idx natural-number/c]) list?]{Add a list at a specified 0-based index of another list
@(hlu-eval #f
(insert-at '(a b c e) '(d) 3))}
@defproc[(list-remf* [#:pred p (-> any/c boolean?) void?]) list?]{Create a list and filter out all elements that match the predicate.

@(hlu-eval #f
(define (get-employees-1 [include-offsite #f])
  (list  'alice (when include-offsite 'bob)))

(define (get-employees-2 [include-offsite #f])
  (list-remf*  'alice (when include-offsite 'bob)))

(get-employees-1)
(get-employees-2)

(define (get-people [exclude none/c]) ; by default, exclude nothing 
  (list-remf* #:pred exclude
              (hash 'name 'alice   'employed #t)
              (hash 'name 'bob     'employed #t 'handed 'left)
              (hash 'name 'charlie 'employed #f)
              (hash 'name 'denise  'employed #f)))

(get-people)
(define unemployed (get-people (λ (h) (hash-ref h 'employed))))
unemployed
(define handedness-unknown (get-people (λ (h) (hash-has-key? h 'handed))))
handedness-unknown
)}


@defproc[(list/not-null? [v any/c]) boolean?]{Returns true if @racketidfont{v} is a pair and not @racket['()]. NB: checks for pair, not list, so it treats @racket['(x . y)] as a list.}

@defproc[(list->values [l list?]) any]{Multiple-value return of all items in a list
@(hlu-eval #f
(list->values '(a b c)))}

@defproc[(member-rec [target any/c] [lst list?]) list?]{Finds elements in @racketidfont{lst} that match `@racketidfont{target}', regardless of how deeply nested.  `@racketidfont{target}' can be either a value or a predicate; in the latter case, all values that match the predicate will be returned.
@(hlu-eval #f
(define l '(1 2 (table 1) ((4) 5 (((table 2 (table 3)))))))
(member-rec 2 l)                  
(member-rec (curry equal? 2) l)   
(member-rec number? l)            
(member-rec (lambda (x) (and (list/not-null? x)
                             (equal? (car x) 'table)))
            l))}

@defproc[(find-contiguous-runs [data list?]
                               [#:key extract-key (-> any/c any/c) identity]
			       [#:op  op  (-> any/c any/c boolean?) #f])	
			       list?]{

 Generate a list of lists where each sublist is a sequence of
 consecutive elements.  For example, if given this list:

    @racket['(1 2 3 5 7 200 201 202 203)]

 Then you would get this result:

    @racket['((1 2 3) (5) (7) (200 201 202 203))]

 Keyword arguments are:

    @racket[#:key] Function to use in order to generate the values that
    define what a run is.  By default this is @racket[identity].  You can
    pass a function of @racket[(-> any/c any/c)] to use instead.

    @racket[#:op] The function to use for determining if two elements are
    contiguous.  By default this is:

      @racket[(lambda (a b) (= (add1 (extract-key a) (extract-key b))))]

   If that doesn't work for your use case, you can pass a function of  @racket[(-> any/c any/c boolean?)]

@(hlu-eval
     #f
     (list->values (find-contiguous-runs (list (hash 'age 17) (hash 'age 18) (hash 'age 27))
     		                         #:key (curryr hash-ref 'age))))
}

@defproc[(remove-nulls [lst list?]) list?]{Filter @racket['()]s out of a list}

@defproc*[([(safe-first [lst list?][default any/c '()]) any/c]
           [(safe-rest  [lst list?][default any/c '()]) any/c])]{
  When @racketidfont{lst} is non-null these work like @racket[first] and @racket[rest] respectively.

When @racketidfont{lst} is null then these return @racketidfont{default}

@(hlu-eval #f
(safe-first '(a b c))
(safe-first '())
(safe-first '() #f)
(safe-rest '(a b c))
(safe-rest '())
(safe-rest '() #f)
)
}.


@section{DEPRECATED}

The following will be removed in a future version.  They were mostly written when I was first learning Racket and didn't realize that there was already something that did the thing I wanted.  Either that, or they simply proved to be unnecessary/not useful.

@defproc[(alist->hash [lst (listof pair?)]) hash?]{An alternate name  for @racket[make-immutable-hash].}

@defproc[(L [v any/c] ...) list?]{An alternate name for @racket[list].}
